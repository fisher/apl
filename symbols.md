The charset
===========

 `⍝ ←+-×÷*⍟⌹○!? |⌈⌊⊥⊤⊣⊢ =≠≤<>≥≡≢ ∨∧⍱⍱ ↑↓⊂⊃⎕⍋⍒ ⍳⍷∪∩∊~ /\⌿⍀,⍪⍴⌽⊖⍉ ¨⍨⍣.∘⍤ ⍞⎕⍠⌸⍎⍕ ⋄→⍵⍺∇& ¯⍬`
 
TOC-like table
==============

|          |          |          |          |          |          |          |          |
|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|
| [⍝](#) | [←](#-1) | [+](#-2)  | [-](#-) | [×](#-3)  | [÷](#-4) | [*](#-5) | [⍟](#-6) |
| [⌹](#-7)|[⎕](#-8) | [⍞](#-9)| [⎕](#-10)|[⍠](#-11)|[⌸](#-12)| [!](#-13)| [?](#-14) |
| [○](#-14)| [\|](#-15)| [⌈](#-16)| [⌊](#-17) |[⊥](#-18) |[⊤](#-19)| [⊣](#-20)| [⊢](#-21) |
| [≡](#-22) |[≢](#-23) |[↑](#-24) |[↓](#-25) |[⊂](#-26) |[⊃](#-27) |[⍋](#-28) |[⍒](#-29) |




One rune per day challenge
==========================

I decided to spend a small fraction of my time each day for just one symbol from the language. The trick is in this `each day` part. First day will be exception, because it's nothing special about comments, assignments and arythmetics.

## ⍝

### A comment

Nothing special about it, `C-M-,` comments out the current line, `C-M-.` removes comment mark from the line.
The symbol itself can be generated by `C-S-,`

```apl
⍝___________________
⍝ ... Gibberish mojo
⍝¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

foo/bar ⍝ ... blablabla
```

## ←

### Assingment

Assigns _rval_ to the _lval_. Just press `C-]` to generate the symbol.

```apl
a←10
another_variable ← 200 + a
(yet_another1 yet_another2) ← 100   ⍝ ... yet_another1 = 100, yet_another2 = 100
(yet_another1 yet_another2) ← 10 20  ⍝ ... yet_another1 = 10, yet_another2 = 20
var1 ← var2 ← var3 ← 0  ⍝ ... all three vars are 0 now
```

## +

### Plus

Just a regular plus sign.

#### Monadic

Identity. Returns _rval_ as is.

```apl
var ← +¯10 20 ⍝ ... var is now ¯10 20
```
#### Dyadic

Addition. Sums _lval_ and _rval_. Both can be scalars or vectors. Both should be numeric.

```apl
res ← 1 2 3 + 4 5 6 ⍝ ... res is 5 7 9
res ← 1 2 3 + 4     ⍝ ... res is 5 6 7, rval expands to the length of lval (4 4 4)
res ← 1 + 2 3 4     ⍝ ... res is 3 4 5, lval expands to the length of rval (1 1 1)
res ← 2 3 4 + 10 20 ⍝ ... throws LENGTH ERROR: Mismatched left and right argument shapes
```

## -

### Minus

Regular minus sign.

#### Monadic

Negates the number.

```apl
var ← -10    ⍝ ... var is now ¯10
var ← - 4j7  ⍝ ... var is ¯4j¯7
```
#### Dyadic

Substraction.

Both _rval_ and _lval_ can be scalar or array, both should be numeric. Result is numeric.

```apl
var ← 5 - 2 3 4  ⍝ ... var is 3 2 1 (lval extends to the length of the rval, (5 5 5))
var ← 5 4 3 - 2  ⍝ ... var is 3 2 1 (rval expands to the length of the lval, (2 2 2))
var ← 2j3 - .3j5 ⍝ ... var is 1.7J¯2; (a+bi)-(c+di) = (a-c)+(b-d)i
```

## ×

### Multiplication

Press `C-=` to generate the symbol.

#### Monadic

Sign of. (AKA _signum_, AKA _direction_).

For integers and floats, the function returns ¯1, 0, or 1 for negative, zero or positive argument, respectively.

```apl
var ← × 12 0 ¯12 ⍝ ... var now contains vector 1 0 ¯1
```

For complex numbers, monadic _signum_ is equivalent to _rval_ ÷| _rval_.

```apl
var ← × 3j4 4j5       ⍝ ... var is 0.6J0.8 0.6246950476J0.7808688094
res ← {⍵÷|⍵} 3j4 4j5 ⍝ ... res is 0.6J0.8 0.6246950476J0.7808688094
res ← | ×3j4 4j5      ⍝ ... res is 1 1
```

#### Dyadic

Multiplication. Surprise-surprise

```apl
res ← 1 2 3 × 4 5 6 ⍝ ... res is 4 10 18, a b c × x y z = a×x b×y c×z
res ← 1 2 3 × 4     ⍝ ... res is 4 8 12, rval expands to the length of lval (4 4 4)
res ← 1 × 2 3 4     ⍝ ... res is 2 3 4,  lval expands to the length of rval (1 1 1)
res ← 2j3 × 1 4 5j6 ⍝ ... res is 2j3 8j12 ¯8j27
res ← 2 3 4 × 10 20 ⍝ ... throws LENGTH ERROR: Mismatched left and right argument shapes
```

## ÷

### Division

Press `C-[` to generate the symbol.

#### Monadic

Reciprocal. Returns 1/_rval_ relation.

```apl
var ← ÷ 1 2 3 4 5  ¯4 ¯5 ⍝ ... var now 1 0.5 0.33333333333333 0.25 0.2 ¯0.25 ¯0.2
```

Internal representation seems not to be simple IEEE 754, at least it successfully passes the well-known pitfall with floating point division:

```apl
var ← ÷ 3    ⍝ ... var now 0.33333333333333
var ← var ×3 ⍝ ... var is 1 again
```

...but looks like a workaround for boundary case. In example below, first multiplication is using 14 digits after the dot, while the second is using 15 digits precision.

```apl
      0.33333333333333×3
0.99999999999999
      0.333333333333333×3
1
```

**NB:** `÷0` throws `DOMAIN ERROR: Divide by zero` if `⎕DIV` equals to 0; if `⎕DIV` = 1, `÷0` returns 0.

By default, `⎕DIV` equals to 0.

#### Dyadic

Division.

```apl
var ← 6 ÷ 3 ⍝ ... var = 2
```

**NB:** System variable `⎕DIV` is an implicit argument of division function. In pseudocode:

If (_rval_ == 0)
  - If (_⎕DIV_ == 0)
    + If (_lval_ == 0)
      * return 1;
    + Else
      * throw 'DOMAIN ERROR';
  - Else
    + return 0;

```apl
⎕DIV ← 1
var ← ¯1 0 1 ÷ 1 1 1  ⍝ ... var = ¯1 0 1
var ← ¯1 0 1 ÷ 0 0 0  ⍝ ... var =  0 0 0
⎕DIV ← 0
var ← ¯1 0 1 ÷ 1 1 1  ⍝ ... var = ¯1 0 1
var ← ¯1 0 1 ÷ 0 0 0  ⍝ ... throws DOMAIN ERROR because of first and last cases, ¯1÷0 and 1÷0
var ← 0 0 0 ÷ ¯1 0 1  ⍝ ... var =  0 1 0
```

By default, `⎕DIV` equals to 0.

## *

### Exponentiation

Regular asterisk sign.

#### Monadic

Exponential (reverse of natural logarithm)

_rval_ should be numeric. Result is numeric and equals to the _rval_'s power of _e_, i.e. _e_<sup>rval</sup>

```apl
var ← * 1 0 ⍝ ... var equals to 2.718281828 1
```

#### Dyadic

Power

```apl
var ← 10 * 3 ⍝ ... var equals to 1000
```

Common idiom is to find a square root by powering to 1/2,

```apl
var ← 16 * ÷2 ⍝ ... this gives us the square root of 16, 4
var ← 27 * ÷3 ⍝ ... this gives us the cubic root of 27, it's 3
var ← 16 * ÷4 ⍝ ... equals to 2
```

## ⍟

### Logarithm

Press `C-S-8` to generate the symbol.

#### Monadic

Natural logarithm

```apl
      ⍟10 100 1000 10000
2.302585092994 4.6051701859881 6.9077552789821 9.2103403719762
      ⍟2 4 8 16 32
0.69314718055995 1.3862943611199 2.0794415416798 2.7725887222398 3.4657359027997
      ⍟1
0
      *1
2.718281828459
      ⍟*1
1
      {⍵:⎕←'yep'⋄⎕←'nope'}1=⍟*1
yep
```

#### Dyadic

Logarithm of a given _lval_ base

Defined in terms of monadic (natural) logarithm: `lval ⍟ rval == (⍟rval) ÷ ⍟lval`

```apl
var ← (10⍟100)                 ⍝ ... var equals to 2
bool← (10⍟100) = (⍟100)÷⍟10   ⍝ ... bool is 1
base← 16⍟256 512 1024 2048 4096 ⍝ ... base is vector 2 2.25 2.5 2.75 3
```
