The charset
===========

 `⍝ ←+-×÷*⍟⌹○!? |⌈⌊⊥⊤⊣⊢ =≠≤<>≥≡≢ ∨∧⍱⍲ ↑↓⊂⊃⌷⍋⍒ ⍳⍷∪∩∊~ /\⌿⍀,⍪⍴⌽⊖⍉ ¨⍨⍣.∘⍤ ⍞⎕⍠⌸⍎⍕ ⋄→⍵⍺∇& ⍙∆ß¢⍫⌶ ¯⍬`
 
TOC-like table
==============

|          |          |          |          |          |          |          |          |
|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|
| [⍝](#) | [←](#-1) | [+](#-2)  | [-](#-) | [×](#-3)  | [÷](#-4) | [*](#-5) | [⍟](#-6) |
| [⌹](#-7)|[⌷](#-8) | [⍞](#-9)| [⎕](#-10)|[⍠](#-11)|[⌸](#-12)| [!](#-13)| [?](#-14) |
| [○](#-15)| [\|](#-16)| [⌈](#-17)| [⌊](#-18) |[⊥](#-19) |[⊤](#-20)| [⊣](#-21)| [⊢](#-22) |
| [≡](#-23) |[≢](#-24) |[↑](#-25) |[↓](#-26) |[⊂](#-27) |[⊃](#-28) |[⍋](#-29) |[⍒](#-30) |
| [&](#-31) | [⌶](#-32) | [⍳](#-33) | [⍷](#-34) | [∊](#-35) | [∪](#-36) | [∩](#-37) | [⍴](#-38) |
| [⋄](#-39) | [→](#-40) | [,](#-41) | [⍪](#-42) | [¨](#-43) | [⍨](#-44) | [⍣](#-45) | [⍤](#-46) |
| [~](#-47) | [/](#-48) | [\\](#-49) | [⌿](#-50) | [⍀](#-51) | [⌽](#-52) | [⊖](#-53) | [⍉](#-54) |
| [∘](#-55) | [⍬](#-56) | [.](#-57) | [¢](#-58) | [⍎](#-59) | [⍕](#-60) | [⍺](#-61) | [⍵](#-62) |
| [¯](#-63) | [≠](#-64) | [=](#-65) | [≤](#-66) | [<](#-67) | [>](#-68) | [≥](#-69) | [⊆](#-70) |
| [∇](#-71) | [∆](#-72) | [∨](#-73) | [∧](#-74) | [⍱](#-75) | [⍲](#-76) | [⍫](#-77) | [⍙](#-78) |

[ß](#ß)

Placeholder for [Other, unsorted](#other-unsorted) symbols and notes

One rune per day challenge
==========================

I decided to spend a small fraction of my time each day for just one symbol from the language. The trick is in this `each day` part. First day will be an exception, because it's nothing special about comments, assignments and arythmetics.

## ⍝

### A comment

Nothing special about it, comment out from the symbol till the end of a line.

Press `C-M-,` to comment out the current line, `C-M-.` removes comment mark from the line.
The symbol itself can be generated by `C-S-,`

```apl
⍝___________________
⍝ ... Gibberish mojo
⍝¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

foo/bar ⍝ ... blablabla
```

## ←

### Assingment

#### Monadic

_No use_

#### Dyadic

Assigns _rval_ to the _lval_. Just press `C-]` to generate the symbol.

```apl
a←10
another_variable ← 200 + a
(yet_another1 yet_another2) ← 100   ⍝ ... yet_another1 = 100, yet_another2 = 100
(yet_another1 yet_another2) ← 10 20  ⍝ ... yet_another1 = 10, yet_another2 = 20
var1 ← var2 ← var3 ← 0  ⍝ ... all three vars are 0 now
```

#### Assignment with index

Reading right to left, `Variable[index_vector] ← values_vector` means assignment of _values_vector_ to (vector) _Variable_ addressed by _index_vector_.

```apl
var ← ⍳5           ⍝ ... var is 1 2 3 4 5
var[2 3] ← 111     ⍝ ... var is 1 111 111 4 5
var[2 3] ← 222 333 ⍝ ... var is 1 222 333 4 5
var[4 4] ← 444 555 ⍝ ... var is 1 222 333 555 5
```

Shape should agree:

```apl
      var ← 2 3⍴ ⍳6 ⋄var
1 2 3
4 5 6
      var[1 2;2 3]←2 2⍴44 55 ⋄var
1 44 55
4 44 55
      var[1 2;2]←2 1⍴66 77 ⋄ var
1 66 55
4 77 55
```

## +

### Plus

Just a regular plus sign.

#### Monadic

Identity. Returns _rval_ as is.

```apl
var ← +¯10 20 ⍝ ... var is now ¯10 20
```
#### Dyadic

Addition. Sums _lval_ and _rval_. Both can be scalars or vectors. Both should be numeric.

```apl
res ← 1 2 3 + 4 5 6 ⍝ ... res is 5 7 9
res ← 1 2 3 + 4     ⍝ ... res is 5 6 7, rval expands to the length of lval (4 4 4)
res ← 1 + 2 3 4     ⍝ ... res is 3 4 5, lval expands to the length of rval (1 1 1)
res ← 2 3 4 + 10 20 ⍝ ... throws LENGTH ERROR: Mismatched left and right argument shapes
```

## -

### Minus

Regular minus sign.

#### Monadic

Negates the number.

```apl
var ← -10    ⍝ ... var is now ¯10
var ← - 4j7  ⍝ ... var is ¯4j¯7
```
#### Dyadic

Substraction.

Both _rval_ and _lval_ can be scalar or array, both should be numeric. Result is numeric.

```apl
var ← 5 - 2 3 4  ⍝ ... var is 3 2 1 (lval extends to the length of the rval, (5 5 5))
var ← 5 4 3 - 2  ⍝ ... var is 3 2 1 (rval expands to the length of the lval, (2 2 2))
var ← 2j3 - .3j5 ⍝ ... var is 1.7J¯2; (a+bi)-(c+di) = (a-c)+(b-d)i
```

## ×

### Multiplication

Press `C-=` to generate the symbol.

#### Monadic

Sign of. (AKA _signum_, AKA _direction_).

For integers and floats, the function returns ¯1, 0, or 1 for negative, zero or positive argument, respectively.

```apl
var ← × 12 0 ¯12 ⍝ ... var now contains vector 1 0 ¯1
```

For complex numbers, monadic _signum_ is equivalent to _rval_ ÷| _rval_.

```apl
var ← × 3j4 4j5       ⍝ ... var is 0.6J0.8 0.6246950476J0.7808688094
res ← {⍵÷|⍵} 3j4 4j5 ⍝ ... res is 0.6J0.8 0.6246950476J0.7808688094
res ← | ×3j4 4j5      ⍝ ... res is 1 1
```

#### Dyadic

Multiplication. Surprise-surprise

```apl
res ← 1 2 3 × 4 5 6 ⍝ ... res is 4 10 18, a b c × x y z = a×x b×y c×z
res ← 1 2 3 × 4     ⍝ ... res is 4 8 12, rval expands to the length of lval (4 4 4)
res ← 1 × 2 3 4     ⍝ ... res is 2 3 4,  lval expands to the length of rval (1 1 1)
res ← 2j3 × 1 4 5j6 ⍝ ... res is 2j3 8j12 ¯8j27
res ← 2 3 4 × 10 20 ⍝ ... throws LENGTH ERROR: Mismatched left and right argument shapes
```

## ÷

### Division

Press `C-[` to generate the symbol.

#### Monadic

Reciprocal. Returns 1/_rval_ relation.

```apl
var ← ÷ 1 2 3 4 5  ¯4 ¯5 ⍝ ... var now 1 0.5 0.33333333333333 0.25 0.2 ¯0.25 ¯0.2
```

Internal representation seems not to be simple IEEE 754, at least it successfully passes the well-known pitfall with floating point division:

```apl
var ← ÷ 3    ⍝ ... var now 0.33333333333333
var ← var ×3 ⍝ ... var is 1 again
```

...but looks like a workaround for boundary case. In example below, first multiplication is using 14 digits after the dot, while the second is using 15 digits precision.

```apl
      0.33333333333333×3
0.99999999999999
      0.333333333333333×3
1
```

**NB:** `÷0` throws `DOMAIN ERROR: Divide by zero` if `⎕DIV` equals to 0; if `⎕DIV` = 1, `÷0` returns 0.

By default, `⎕DIV` equals to 0.

#### Dyadic

Division.

```apl
var ← 6 ÷ 3 ⍝ ... var = 2
```

**NB:** System variable `⎕DIV` is an implicit argument of division function. In pseudocode:

If (_rval_ == 0)
  - If (_⎕DIV_ == 0)
    + If (_lval_ == 0)
      * return 1;
    + Else
      * throw 'DOMAIN ERROR';
  - Else
    + return 0;

```apl
⎕DIV ← 1
var ← ¯1 0 1 ÷ 1 1 1  ⍝ ... var = ¯1 0 1
var ← ¯1 0 1 ÷ 0 0 0  ⍝ ... var =  0 0 0
⎕DIV ← 0
var ← ¯1 0 1 ÷ 1 1 1  ⍝ ... var = ¯1 0 1
var ← ¯1 0 1 ÷ 0 0 0  ⍝ ... throws DOMAIN ERROR because of first and last cases, ¯1÷0 and 1÷0
var ← 0 0 0 ÷ ¯1 0 1  ⍝ ... var =  0 1 0
```

By default, `⎕DIV` equals to 0.

## *

### Exponentiation

Regular asterisk sign.

#### Monadic

Exponential (reverse of natural logarithm)

_rval_ should be numeric. Result is numeric and equals to the _rval_'s power of _e_, i.e. _e_<sup>rval</sup>

```apl
var ← * 1 0 ⍝ ... var equals to 2.718281828 1
```

#### Dyadic

Power

```apl
var ← 10 * 3 ⍝ ... var equals to 1000
```

Common idiom is to find a square root by powering to 1/2,

```apl
var ← 16 * ÷2 ⍝ ... this gives us the square root of 16, 4
var ← 27 * ÷3 ⍝ ... this gives us the cubic root of 27, it's 3
var ← 16 * ÷4 ⍝ ... equals to 2
```

## ⍟

### Logarithm

Press `C-S-8` to generate the symbol.

#### Monadic

Natural logarithm

```apl
      ⍟10 100 1000 10000
2.302585092994 4.6051701859881 6.9077552789821 9.2103403719762
      ⍟2 4 8 16 32
0.69314718055995 1.3862943611199 2.0794415416798 2.7725887222398 3.4657359027997
      ⍟1
0
      *1
2.718281828459
      ⍟*1
1
      {⍵:⎕←'yep'⋄⎕←'nope'}1=⍟*1
yep
```

#### Dyadic

Logarithm of a given _lval_ base

Defined in terms of monadic (natural) logarithm: `lval ⍟ rval == (⍟rval) ÷ ⍟lval`

```apl
var ← (10⍟100)                 ⍝ ... var equals to 2
bool← (10⍟100) = (⍟100)÷⍟10   ⍝ ... bool is 1
base← 16⍟256 512 1024 2048 4096 ⍝ ... base is vector 2 2.25 2.5 2.75 3
```

## ⌹

### Matrix divide (aka domino)

Press `C-S-[` to generate the symbol. Associate with regular division, which is `C-[`.

There are some similarities between this sign (⌹) and division sign ([÷](#-4)) - Matrix division looks the same, but in frame.

#### Monadic

'Matrix inverse of'.

#### Dyadic

'Matrix division by'.

Both _rval_ and _lval_ must be a simple numeric array of rank 2 or less, and _rval_ must be non-singular.
A scalar argument is treated as a matrix with one-element. If argument is a vector, it is treated as a single column matrix.
The number of rows in both arguments must be the same, and _rval_ must have at least the same number of rows as columns.

The _result_ is the matrix division of _lval_ by _rval_. That is, the matrix product `rval +.× result = lval`.

_result_ is determined such that `(lval - rval +.× result) * 2` is minimised.

The shape of _result_ is `(1↓⍴ rval), 1↓⍴ lval`.

```apl
    (1 4⍴1 2 3 4) ⌹ 2
0.5 1 1.5 2
    (2 4⍴1 2 3 4 5 6 7 8) ⌹ 1 2
2.2 2.8 3.4 4
    (2 4⍴1 2 3 4 5 6 7 8) ⌹ 2
LENGTH ERROR
    (2 4⍴1 2 3 4 5 6 7 8)⌹2
                           ∧
    (2 4⍴1 2 3 4 5 6 7 8) ⌹ (2 2⍴1 2 3 4)
 3 2 1 0
¯1 0 1 2
```

For least square method and linear regression examples please see Language Reference Guide from Dyalog.

## ⌷

### Index (axis)

Press `C-S-L` to generate the symbol. Sometimes called _squad index_ or _squad indexing_. Don't confuse it with quad symbol (which is slightly wider, `⎕`) and with two square brackets ([]).

#### Monadic

_No info_

#### Dyadic

#### Special case, as operator together with square brackets

So called _index with axis_, in the form _lval_ ⌷[_index_] _rval_

## ⍞

### Quoted quad

#### Monadic

#### Dyadic

## ⎕

### Quad

#### Monadic

#### Dyadic

## ⍠

### Variant

#### Monadic

#### Dyadic

## ⌸

### Key

#### Monadic

#### Dyadic

## !

### Exlamation mark

#### Monadic

Factorial.

```apl
      !1 2 3 4 5
1 2 6 24 120
```

#### Dyadic

Binomial Coefficient. Number of combinations of _rval_ items taken _lval_ at a time

```apl
      1 2 3 4 5 6!6
6 15 20 15 6 1
      2!4 5 6 7 8
6 10 15 21 28
      3!4 5 6 7 8
4 10 20 35 56
      4!4 5 6 7 8
1 5 15 35 70
      5!4 5 6 7 8
0 1 6 21 56
      6!4 5 6 7 8
0 0 1 7 28
```

## ?

### Question mark

#### Monadic

#### Dyadic

## ○

### Circular (π-times)

#### Monadic

So called π× or pi-times. Press 'C-o' to enter the symbol.

Multiplication by the value of π constant, so _rval_ should be numeric, and _result_ will be numeric.

```apl
    ○0 1 2
0 3.1415926535898 6.2831853071796
    ○1j2 2j1 1j1
3.1415926535898J6.2831853071796 6.2831853071796J3.1415926535898 3.1415926535898J3.1415926535898
```

Non-numeric _rval_ produces DOMAIN ERROR.

#### Dyadic

So called 'circular'. Key combo is 'C-o'.

_Result_ depends on the _lval_ value, which can be an integer in the range `¯12 ... 12`. The _rval_ should be numeric in any case. _Result_ is always numeric.

## \|

### Residue, or magnitude

## ⌈

### Maximum, ceiling

## ⌊

### Minimum, floor

## ⊥

### Decode

## ⊤

### Encode

## ⊣

### Same, left

## ⊢

### Same, right

## ≡
### Depth, match
## ≢
### Not match, tally
## ↑
### Disclose, mix, take
## ↓
### Drop, split
## ⊂
### Left shoe
## ⊃
### Right shoe
## ⍋
## ⍒
## &
## ⌶
## ⍳
## ⍷
## ∊
## ∪
## ∩
## ⍴
## ⋄
## →
## ,
## ⍪
## ¨
## ⍨
## ⍣
## ⍤
## ~
## /
## \\
## ⌿
## ⍀
## ⌽
## ⊖
## ⍉
## ∘
## ⍬
## .
## ¢
## ⍎
## ⍕
## ⍺
## ⍵
## ¯
## ≠
## =
## ≤
## <
## >

### Greater than (GT)

## ≥

### Greater than or equal (GTE)

## ⊆
### Left Shoe Underbar

#### Monadic

Classic Edition: the symbol ⊆ (Left Shoe Underbar) is not available in Classic
Edition, and Nest is instead represented by ⎕U2286.

#### Dyadic

Classic Edition: the symbol ⊆ (Left Shoe Underbar) is not available in Classic
Edition, and Partition is instead represented by ⎕U2286.

## ∇
## ∆
## ∨

### Logical Or

#### Monadic

#### Dyadic

Greatest Common Divisor

## ∧

### Logical And

#### Monadic

#### Dyadic

##### If _rval_ and _lval_ are both boolean,

...then _result_ is also boolean, nothing special about logical and,

```apl
      0 1 0 1 ∧ 1 1 0 0
0 1 0 0
      0 1 0 1 ∧ 1
0 1 0 1
      0 1 0 1 ∧ 0
0 0 0 0
      1 ∧ 1 1 0 0
1 1 0 0
      0 ∧ 1 1 0 0
0 0 0 0
```

##### If one of, or both _lval_ and _rval_ are numeric,

...then _result_ is the Least Common Multiple of _lval_ and _rval_.

```apl
      0 1 2 3 5 15 ∧ 1 2 3 4 5 35
0 2 6 12 5 105
      5 ∧ 1 2 3 4 5 6 7 8 9
5 10 15 20 5 30 35 40 45
```

**NB:** in this case, `⎕CT` and `⎕DCT` are implicit arguments to a '^' function.

## ⍱
## ⍲
## ⍫
## ⍙

## ß

### it's not Beta, it seems like german double S

Where did I find it? I copied it from somewhere

Cannot find it in Dyalog APL language reference, tought.

Maybe should be removed from the index as well.

## Other, unsorted

Just a placeholder for now.

Maybe will take shortnotes here.

Maybe it's a place to describe operators.

Or trains.

Or Quad-symbols.

But unsorted. For now.
