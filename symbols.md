*Nota Bene*: work in progress (as of 2020.06.17)

The charset
===========

 `⍝ ←+-×÷*⍟⌹○!? |⌈⌊⊥⊤⊣⊢ =≠≤<>≥≡≢ ∨∧⍱⍲ ↑↓⊂⊃⌷⍋⍒ ⍳⍷∪∩∊~ /\⌿⍀,⍪⍴⌽⊖⍉ ¨⍨⍣.∘⍤ ⍞⎕⍠⌸⍎⍕ ⋄→⍵⍺∇& ⍙∆ß¢⍫⌶ ¯⍬`

TOC-like table
==============

|          |          |          |          |          |          |          |          |
|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|
| [⍝](#) | [←](#-1) | [+](#-2)  | [-](#-) | [×](#-3)  | [÷](#-4) | [*](#-5) | [⍟](#-6) |
| [⌹](#-7)|[⌷](#-8) | [⍞](#-9)| [⎕](#-10)|[⍠](#-11)|[⌸](#-12)| [!](#-13)| [?](#-14) |
| [○](#-15)| [\|](#-16)| [⌈](#-17)| [⌊](#-18) |[⊥](#-19) |[⊤](#-20)| [⊣](#-21)| [⊢](#-22) |
| [≡](#-23) |[≢](#-24) |[↑](#-25) |[↓](#-26) |[⊂](#-27) |[⊃](#-28) |[⍋](#-29) |[⍒](#-30) |
| [&](#-31) | [⌶](#-32) | [⍳](#-33) | [⍷](#-34) | [∊](#-35) | [∪](#-36) | [∩](#-37) | [⍴](#-38) |
| [⋄](#-39) | [→](#-40) | [,](#-41) | [⍪](#-42) | [¨](#-43) | [⍨](#-44) | [⍣](#-45) | [⍤](#-46) |
| [~](#-47) | [/](#-48) | [\\](#-49) | [⌿](#-50) | [⍀](#-51) | [⌽](#-52) | [⊖](#-53) | [⍉](#-54) |
| [∘](#-55) | [⍬](#-56) | [.](#-57) | [¢](#-58) | [⍎](#-59) | [⍕](#-60) | [⍺](#-61) | [⍵](#-62) |
| [¯](#-63) | [≠](#-64) | [=](#-65) | [≤](#-66) | [<](#-67) | [>](#-68) | [≥](#-69) | [⊆](#-70) |
| [∇](#-71) | [∆](#-72) | [∨](#-73) | [∧](#-74) | [⍱](#-75) | [⍲](#-76) | [⍫](#-77) | [⍙](#-78) |

[ß](#ß)

Placeholder for [Other, unsorted](#other-unsorted) symbols and notes

One rune per day challenge
==========================

I decided to spend a small fraction of my time each day for just one symbol from the language. The trick is in this `each day` part. First day will be an exception, because it's nothing special about comments, assignments and arythmetics.

## ⍝

### A comment

Nothing special about it, comment out from the symbol till the end of a line.

Press `C-M-,` to comment out the current line, `C-M-.` removes comment mark from the line.
The symbol itself can be generated by `C-S-,`

```apl
⍝___________________
⍝ ... Gibberish mojo
⍝¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

foo/bar ⍝ ... blablabla
```

## ←

### Assingment

#### Monadic

_No use_

#### Dyadic

Assigns _rval_ to the _lval_. Just press `C-]` to generate the symbol.

```apl
a←10
another_variable ← 200 + a
(yet_another1 yet_another2) ← 100   ⍝ ... yet_another1 = 100, yet_another2 = 100
(yet_another1 yet_another2) ← 10 20  ⍝ ... yet_another1 = 10, yet_another2 = 20
var1 ← var2 ← var3 ← 0  ⍝ ... all three vars are 0 now
```

#### Assignment with index

Reading right to left, `Variable[index_vector] ← values_vector` means assignment of _values_vector_ to (vector) _Variable_ addressed by _index_vector_.

```apl
var ← ⍳5           ⍝ ... var is 1 2 3 4 5
var[2 3] ← 111     ⍝ ... var is 1 111 111 4 5
var[2 3] ← 222 333 ⍝ ... var is 1 222 333 4 5
var[4 4] ← 444 555 ⍝ ... var is 1 222 333 555 5
```

Shape should agree:

```apl
      var ← 2 3⍴ ⍳6 ⋄var
1 2 3
4 5 6
      var[1 2;2 3]←2 2⍴44 55 ⋄var
1 44 55
4 44 55
      var[1 2;2]←2 1⍴66 77 ⋄ var
1 66 55
4 77 55
```

## +
### Plus

Just a regular plus sign.

#### Monadic

Identity. Returns _rval_ as is.

```apl
var ← +¯10 20 ⍝ ... var is now ¯10 20
```
#### Dyadic

Addition. Sums _lval_ and _rval_. Both can be scalars or vectors. Both should be numeric.

```apl
res ← 1 2 3 + 4 5 6 ⍝ ... res is 5 7 9
res ← 1 2 3 + 4     ⍝ ... res is 5 6 7, rval expands to the length of lval (4 4 4)
res ← 1 + 2 3 4     ⍝ ... res is 3 4 5, lval expands to the length of rval (1 1 1)
res ← 2 3 4 + 10 20 ⍝ ... throws LENGTH ERROR: Mismatched left and right argument shapes
```

## -
### Minus

Regular minus sign.

#### Monadic

Negates the number.

The argument can be any numeric array. _Result_ is numeric and is the negative value of the argument. For complex
numbers both the real and imaginary parts are negated.

```apl
var ← -10    ⍝ ... var is now ¯10
var ← - 4j7  ⍝ ... var is ¯4j¯7
```
#### Dyadic

Substraction.

Both _rval_ and _lval_ can be scalar or array, both should be numeric. Result is numeric.

```apl
var ← 5 - 2 3 4  ⍝ ... var is 3 2 1 (lval extends to the length of the rval, (5 5 5))
var ← 5 4 3 - 2  ⍝ ... var is 3 2 1 (rval expands to the length of the lval, (2 2 2))
var ← 2j3 - .3j5 ⍝ ... var is 1.7J¯2; (a+bi)-(c+di) = (a-c)+(b-d)i
```

## ×

### Multiplication

Press `C-=` to generate the symbol.

#### Monadic

Sign of. (AKA _signum_, AKA _direction_).

For integers and floats, the function returns ¯1, 0, or 1 for negative, zero or positive argument, respectively.

```apl
var ← × 12 0 ¯12 ⍝ ... var now contains vector 1 0 ¯1
```

For complex numbers, monadic _signum_ is equivalent to _rval_ ÷| _rval_.

```apl
var ← × 3j4 4j5       ⍝ ... var is 0.6J0.8 0.6246950476J0.7808688094
res ← {⍵÷|⍵} 3j4 4j5 ⍝ ... res is 0.6J0.8 0.6246950476J0.7808688094
res ← | ×3j4 4j5      ⍝ ... res is 1 1
```

#### Dyadic

Multiplication. Surprise-surprise

```apl
res ← 1 2 3 × 4 5 6 ⍝ ... res is 4 10 18, a b c × x y z = a×x b×y c×z
res ← 1 2 3 × 4     ⍝ ... res is 4 8 12, rval expands to the length of lval (4 4 4)
res ← 1 × 2 3 4     ⍝ ... res is 2 3 4,  lval expands to the length of rval (1 1 1)
res ← 2j3 × 1 4 5j6 ⍝ ... res is 2j3 8j12 ¯8j27
res ← 2 3 4 × 10 20 ⍝ ... throws LENGTH ERROR: Mismatched left and right argument shapes
```

## ÷

### Division

Press `C-[` to generate the symbol.

#### Monadic

Reciprocal. Returns 1/_rval_ relation.

```apl
var ← ÷ 1 2 3 4 5  ¯4 ¯5 ⍝ ... var now 1 0.5 0.33333333333333 0.25 0.2 ¯0.25 ¯0.2
```

Internal representation seems not to be simple IEEE 754, at least it successfully passes the well-known pitfall with floating point division:

```apl
var ← ÷ 3    ⍝ ... var now 0.33333333333333
var ← var ×3 ⍝ ... var is 1 again
```

...but looks like a workaround for boundary case. In example below, first multiplication is using 14 digits after the dot, while the second is using 15 digits precision.

```apl
      0.33333333333333×3
0.99999999999999
      0.333333333333333×3
1
```

**NB:** `÷0` throws `DOMAIN ERROR: Divide by zero` if `⎕DIV` equals to 0; if `⎕DIV` = 1, `÷0` returns 0.

By default, `⎕DIV` equals to 0.

#### Dyadic

Division.

```apl
var ← 6 ÷ 3 ⍝ ... var = 2
```

**NB:** System variable `⎕DIV` is an implicit argument of division function. In pseudocode:

If (_rval_ == 0)
  - If (_⎕DIV_ == 0)
    + If (_lval_ == 0)
      * return 1;
    + Else
      * throw 'DOMAIN ERROR';
  - Else
    + return 0;

```apl
⎕DIV ← 1
var ← ¯1 0 1 ÷ 1 1 1  ⍝ ... var = ¯1 0 1
var ← ¯1 0 1 ÷ 0 0 0  ⍝ ... var =  0 0 0
⎕DIV ← 0
var ← ¯1 0 1 ÷ 1 1 1  ⍝ ... var = ¯1 0 1
var ← ¯1 0 1 ÷ 0 0 0  ⍝ ... throws DOMAIN ERROR because of first and last cases, ¯1÷0 and 1÷0
var ← 0 0 0 ÷ ¯1 0 1  ⍝ ... var =  0 1 0
```

By default, `⎕DIV` equals to 0.

## *
### Exponentiation

Regular asterisk sign.

#### Monadic

Exponential (reverse of natural logarithm)

_rval_ should be numeric. Result is numeric and equals to the _rval_'s power of _e_, i.e. _e_<sup>rval</sup>

```apl
var ← * 1 0 ⍝ ... var equals to 2.718281828 1
```

#### Dyadic

Power

```apl
var ← 10 * 3 ⍝ ... var equals to 1000
```

Common idiom is to find a square root by powering to 1/2,

```apl
var ← 16 * ÷2 ⍝ ... this gives us the square root of 16, 4
var ← 27 * ÷3 ⍝ ... this gives us the cubic root of 27, it's 3
var ← 16 * ÷4 ⍝ ... equals to 2
```

## ⍟
### Logarithm

Press `C-S-8` to generate the symbol.

#### Monadic

Natural logarithm

```apl
      ⍟10 100 1000 10000
2.302585092994 4.6051701859881 6.9077552789821 9.2103403719762
      ⍟2 4 8 16 32
0.69314718055995 1.3862943611199 2.0794415416798 2.7725887222398 3.4657359027997
      ⍟1
0
      *1
2.718281828459
      ⍟*1
1
      {⍵:⎕←'yep'⋄⎕←'nope'}1=⍟*1
yep
```

#### Dyadic

Logarithm of a given _lval_ base

Defined in terms of monadic (natural) logarithm: `lval ⍟ rval == (⍟rval) ÷ ⍟lval`

```apl
var ← (10⍟100)                 ⍝ ... var equals to 2
bool← (10⍟100) = (⍟100)÷⍟10   ⍝ ... bool is 1
base← 16⍟256 512 1024 2048 4096 ⍝ ... base is vector 2 2.25 2.5 2.75 3
```

## ⌹
### Matrix divide (aka domino)

Press `C-S-[` to generate the symbol. Associate with regular division, which is `C-[`.

There are some similarities between this sign (⌹) and division sign ([÷](#-4)) - Matrix division looks the same, but in frame.

#### Monadic

'Matrix inverse of'.

#### Dyadic

'Matrix division by'.

Both _rval_ and _lval_ must be a simple numeric array of rank 2 or less, and _rval_ must be non-singular.
A scalar argument is treated as a matrix with one-element. If argument is a vector, it is treated as a single column matrix.
The number of rows in both arguments must be the same, and _rval_ must have at least the same number of rows as columns.

The _result_ is the matrix division of _lval_ by _rval_. That is, the matrix product `rval +.× result = lval`.

_result_ is determined such that `(lval - rval +.× result) * 2` is minimised.

The shape of _result_ is `(1↓⍴ rval), 1↓⍴ lval`.

```apl
    (1 4⍴1 2 3 4) ⌹ 2
0.5 1 1.5 2
    (2 4⍴1 2 3 4 5 6 7 8) ⌹ 1 2
2.2 2.8 3.4 4
    (2 4⍴1 2 3 4 5 6 7 8) ⌹ 2
LENGTH ERROR
    (2 4⍴1 2 3 4 5 6 7 8)⌹2
                           ∧
    (2 4⍴1 2 3 4 5 6 7 8) ⌹ (2 2⍴1 2 3 4)
 3 2 1 0
¯1 0 1 2
```

For least square method and linear regression examples please see Language Reference Guide from Dyalog.

## ⌷
### Index (AKA squad)

Press `C-S-L` to generate the symbol. Sometimes called _squad index_ or _squad indexing_.
Don't confuse it with quad symbol (which is slightly wider, `⎕`) and with two square brackets ([]).

#### Monadic

_No info_

#### Dyadic

#### Special case, as operator together with square brackets

So called _index with axis_, in the form _lval_ ⌷[_index_] _rval_

## ⍞
### Quoted quad

#### Monadic

#### Dyadic

## ⎕
### Quad

#### Monadic

#### Dyadic

## ⍠
### Variant

#### Monadic

#### Dyadic

## ⌸
### Key

Press `C-S-k` to generate the symbol.

__Nota Bene__: the symbol `⌸` is not available in Classic Edition, and the _Key_
operator is instead represented by `⎕U2338`.

#### Monadic

No use.

```apl
      ⌸1
SYNTAX ERROR
      ⌸1
      ∧
```

#### Dyadic

_Key_ operator in the form _lval_ _f_ ⌸ _rval_, where _lval_ is an optional array, _f_ is a dyadic function, and _rval_ is an array.

TODO: elaborate

## !

### Exlamation mark (factorial, binomial)

#### Monadic

Factorial.

```apl
      !1 2 3 4 5
1 2 6 24 120
```

#### Dyadic

Binomial coefficient. Number of combinations of _rval_ items taken _lval_ at a time

```apl
      1 2 3 4 5 6!6
6 15 20 15 6 1
      2!4 5 6 7 8
6 10 15 21 28
      3!4 5 6 7 8
4 10 20 35 56
      4!4 5 6 7 8
1 5 15 35 70
      5!4 5 6 7 8
0 1 6 21 56
      6!4 5 6 7 8
0 0 1 7 28
```

## ?

### Question mark (Roll, Deal)

#### Monadic

Roll.

__NB:__ `⎕IO` and `⎕RL` are implicit arguments of _Roll_. A side effect of _Roll_ is to change the
value of `⎕RL`.

#### Dyadic

Deal. Takes sample of lenght _lval_ out of set of integers created by ⍳_rval_, i.e. first _rval_ integers, starting from ⎕IO.

Both arguments should be scalar, both positive integers, _rval_ should be greater than or equal to _lval_.

Again, it doesn't work with vectors.

```apl
      2?8
3 6
      8?8
7 2 4 3 1 5 6 8
```

⎕IO and ⎕RL are implicit arguments of Deal. A side effect of Deal is to change the value of ⎕RL.

## ○

### Circular (π-times)

Press 'C-o' to enter the symbol.

#### Monadic

So called π× or pi-times.

Multiplication by the value of π constant, so _rval_ should be numeric, and _result_ will be numeric.

```apl
    ○0 1 2
0 3.1415926535898 6.2831853071796
    ○1j2 2j1 1j1
3.1415926535898J6.2831853071796 6.2831853071796J3.1415926535898 3.1415926535898J3.1415926535898
```

Non-numeric _rval_ produces DOMAIN ERROR.

#### Dyadic

So called 'circular'. Key combo is, again, 'C-o'.

_Result_ depends on the _lval_ value, which can be an integer in the range `¯12 ... 12`. The _rval_ should be numeric in any case. _Result_ is always numeric.

## \|

### Pipe symbol (residue, magnitude)

Usual pipe symbol, press `S-\\` to enter it.

#### Monadic

Magnitude, AKA absolute value. For any numberic _rval_ returns its absolute value. Can operate on arrays.

```apl
      |¯2 ¯1 0 1 2
2 1 0 1 2
      |¯1.5 ¯0.5 0 0.5 1.5
1.5 0.5 0 0.5 1.5
```

Note that the magnitude for a complex number (`a`+i`b`) is defined to be the square root of the sum of `a` squared and `b` squared, i.e. sqrt(a<sup>2</sup>+b<sup>2</sup>).

```apl
      |3j4 5j12
5 13
      |3j12 3j13
12.369316876853 13.341664064126
```

#### Dyadic

Residue.

Arguments are numeric scalars/arrays.

For positive arguments, _result_ is the remainder when _rval_ is divided by _lval_. If _lval_=0, _result_ equals to _rval_.

For other argument values, _result_ is defined as `rval - lval × ⌊ rval ÷ lval + 0 = lval`.
This expression also applies when _lval_ and/or _rval_ are complex but the simple `⌊` is replaced by
the `CpxFloor` function. See [Complex Floor](#-18) function.

```apl
      1 2 3 4 5 6|6
0 0 0 2 1 0
      3|3 4 5 6
0 1 2 0
      4|4 5 6 7 8 9 10 11 12
0 1 2 3 0 1 2 3 0
      3 3 ¯3 ¯3|5 ¯5 4 ¯4
2 1 ¯2 ¯1
      0.5|3.1415 ¯1 ¯0.7
0.1415 0 0.3
      1j2|2j3 3j4 5j6
1J1 ¯1J1 0J1
```
Since this operation involves division, ⎕CT and ⎕DCT are implicit arguments of _Residue_.

## ⌈

### Upstile (maximum, ceiling)

Press `C-s` to generate the symbol.

#### Monadic

Ceiling.

The argument should be a numeric array.

The _ceiling_ function is defined in terms of [floor](#-18) as `⌈ rval ←→ - ⌊ -rval`.

If an element of _rval_ is real, the corresponding element of _result_ is the least integer greater
than or equal to the value of _rval_.

If an element of _rval_ is complex, the corresponding element of _result_ depends on the
relationship between the real and imaginary parts of the numbers in _rval_.

`⎕CT` is an implicit argument of the _ceiling_ function.

#### Dyadic

Maximum.

Both arguments should be numeric scalars/arrays. If both argumets are arrays, the length/rank should be the same.
_Result_ is the maximum of the two sets of _lval_ and _rval_.

```apl
      3⌈1 2 3 4
3 3 3 4
      1 2 3 4⌈3
3 3 3 4
      1 2 3 4⌈4 3 2 1
4 3 3 4
      (2 3⍴(1 2 3 4 5 6))⌈2 3⍴3
3 3 3
4 5 6
      0.2 0.3 0.4 0.5⌈0.3
0.3 0.3 0.4 0.5
```

This function is undefined for complex numbers.

## ⌊

### Downstile (minimum, floor)

Press `C-d` to generate the symbol.

#### Monadic

Floor.

The argument is a numeric array.

##### Real numbers

For real numbers, _result_ is the largest integer value less than or equal to _rval_ within the
comparison tolerance `⎕CT`.

```apl
      ⌊¯1.3 ¯0.7 ¯0 0 0.3 0.7 3.9999999999999
¯2 ¯1 0 0 0 0 3
      ⌊¯1.3 ¯0.7 ¯0 0 0.3 0.7 3.99999999999999
¯2 ¯1 0 0 0 0 4
      ⎕CT
1E¯14
```

##### Complex numbers

The following (deliberately) simple function illustrates one way to express the rules
for evaluating complex _Floor_.

```apl
     ∇ fl←CpxFloor cpxs;a;b
[1]   ⍝ Complex floor of scalar complex number (a+ib)
[2]   a b←9 11○cpxs
[3]   :If 1>(a-⌊a)+b-⌊b
[4]      fl←(⌊a)+0J1×⌊b
[5]   :Else
[6]      :If (a-⌊a)<b-⌊b
[7]         fl←(⌊a)+0J1×1+⌊b
[8]      :Else
[9]         fl←(1+⌊a)+0J1×⌊b
[10]     :EndIf
[11]  :EndIf
     ∇

     CpxFloor¨1j3.2 3.3j2.5 ¯3.3j¯2.5
1J3 3J2 ¯3J¯3
```

`⎕CT` and `⎕DCT` are implicit arguments of the _Floor_ function.

#### Dyadic

Minimum.

Both arguments should be numeric arrays, floats or integers (no comples numbers!).
If both arguments are arrays, the length should be the same.
The _result_ is the array of minimum (corresponding) elements from two sets of arguments.

```apl
      3⌊1 2 3 4 5
1 2 3 3 3
      1 2 3 4 5⌊3
1 2 3 3 3
      1 2 3 4 5⌊5 4 3 2 1
1 2 3 2 1
      (2 3⍴(1 2 3 4 5 6))⌊2 3⍴3
1 2 3
3 3 3
      0.2 0.3 0.4 0.5 0.6⌊0.3
0.2 0.3 0.3 0.3 0.3
      2j3⌊3j4
DOMAIN ERROR
      2J3⌊3J4
         ∧
```

## ⊥

### Decode

#### Monadic

#### Dyadic

## ⊤

### Encode

#### Monadic

#### Dyadic

## ⊣

### Same, left

#### Monadic

#### Dyadic

## ⊢

### Same, right

#### Monadic

#### Dyadic

## ≡

### Depth, match

#### Monadic

#### Dyadic

## ≢

Note: depending on the font used, this symbol can be seen as `depth` symbol with slash attached to its left;
the proper look should be `depth` symbol that is crossed out by a slash, from top right to bottom left, in one placeholder.

### Not match, tally

#### Monadic

#### Dyadic

## ↑
### Disclose, mix, take
## ↓
### Drop, split
## ⊂
### Left shoe

Press `C-z` to generate the symbol.

#### Monadic

Enclose

#### Dyadic

In APL2 standard, it's always Partition.

In Dyalog APL however, the function depends on the `⎕ML` value.

##### `⎕ML` <3

Partitioned enclose.

##### `⎕ML` ≥ 3

Partition.

## ⊃
### Right shoe
## ⍋
## ⍒
## &
## ⌶
## ⍳
## ⍷
## ∊
## ∪
## ∩
## ⍴
## ⋄

### Diamond

Not to be confused with _jot_ symbol (see [∘](#-55)). This one looks like a rhombus, or diamond, while the _jot_ symbol is just a small circle.

Press `C-\` to generate the symbol.

#### Dyadic

Statement separator.

Optionally separates a single APL statement into 2 expressions. When a statement is executed, the expressions separated by diamods are evaluated sequentially from left to right.

```apl
      A←1 ⋄ A←7 ⋄ A←3
      A
3
```

## →

### Abort, Branch

#### Nilladic

Abort. This is a special case of the Branch function used in the niladic sense. If it occurs in a
statement it must be the only symbol in an expression or the only symbol forming an
expression in a text string to be executed by ⍎. It clears the most recently suspended
statement and all of its pendent statements from the state indicator.
The Abort function has no explicit result. The function is not in the function domain
of operators.

```apl
   ∇ F
[1] 'F[1]'
[2] G
[3] 'F[3]'
   ∇
   ∇ G
[1] 'G[1]'
[2] →
[3] 'G[3]'
   ∇
   F
F[1]
G[1]
```

#### Monadic

Branch. _Rval_ may be a scalar or vector which, if not empty, has a simple numeric scalar as its first
element. The function has no explicit result. It is used to modify the normal
sequence of execution of expressions or to resume execution after a statement has
been interrupted. Branch is not in the function domain of operators.

**TODO**

#### Dyadic

_No use_

## ,
## ⍪
## ¨
## ⍨
## ⍣
## ⍤
## ~
## /
## \\
## ⌿
## ⍀
## ⌽
## ⊖
## ⍉
## ∘

### Jot

Not to be confused with `○` symbol ([○](#-15), _circular_, or _π-times_). This particular one is smaller.

Press `C-j` to generate the symbol.

#### Compose operator

TODO: very wide topic here

## ⍬

### Zilde

Press `C-S-=` to generate the symbol

Syntactic sugar for the empty vector (`⍳0`). Seen as a numeric constant.

```apl
      ⍬

      ⍴⍬
0
      DPX ⍬
┌⊖┐
│0│
└~┘
      ⍬23
   23
      12⍬23
12    23
      DPX 12⍬23
┌→──────────┐
│    ┌⊖┐    │
│ 12 │0│ 23 │
│    └~┘    │
└∊──────────┘
      DPX 12 (⍳0) 23
┌→──────────┐
│    ┌⊖┐    │
│ 12 │0│ 23 │
│    └~┘    │
└∊──────────┘
```

## .

### Period (or dot, or point)

Regular full period sign, `.`, it has a special meaning in the APL syntax.

#### Decimal point

In numeric literals, means decimal point. That is, it splits up integer part to the left of it from the fractional part to the right. Examples are `1.2`, `21.34`, `12.34j5.6`.

#### Name separator

TODO: WTF

#### Inner product

As part of _inner product_ operator: `lval f.g rval`, where `f` and `g` are functions allowed in inner product operator.

TODO: elaborate

#### Outer product

Syntax for _outer product_ includes the _point_ in it: `lval ∘.g rval`, where `g` is a funcion allowed in outer product operator.

TODO: elaborate

## ¢

It is generated when I press `C-S-.` in my Dyalog APL session.

Don't see any application for the symbol. It can't be used in variable names, it has no special meaning as a function.

```apl
      ¢
SYNTAX ERROR: Invalid token
      ¢
      ∧
      ¢←0
SYNTAX ERROR: Invalid token
      ¢←0
      ∧

      ¢1
SYNTAX ERROR: Invalid token
      ¢1
      ∧
      1¢0
SYNTAX ERROR: Invalid token
      1 ¢0
        ∧
```

## ⍎
## ⍕

### Thorn symbol, AKA Format

Press `C-S-'` to generate the symbol

#### Monadic

Monadic format.

The argument can be any array. _Result_ is a simple character array which will display identically to
the display produced by the argument. The result is independent of `⎕PW`. If _rval_ is a simple
character array, then _result_ is _rval_.

#### Dyadic

Dyadic format.


## ⍺

### Alpha

Press `C-a` to generate the symbol.

Used as a predefined variable inside anonymous (lambda) function, or _unnamed dfns_. Contains left argument to lambda function.

The variable is read-only except the case when there is no left argument to the lambda function. This can be used
to set the default value for the left argument:

```apl
      fn←{⍺←10⋄100+⍺+⍵}
      20 fn 3
123
      fn 3
113
```

Not defined outside the scope of the lambda:

```apl
      ⍺
SYNTAX ERROR
      ⍺
      ∧
```

Has no special meaning as a monadic function:

```apl
      ⍺ 3
SYNTAX ERROR
      ⍺ 3
      ∧
```

Cannot be used as a variable name or inside the variable name:

```apl
      ⍺←2
SYNTAX ERROR
      ⍺←2
      ∧
      ⍺lpha←1
SYNTAX ERROR
      ⍺ lpha←1
      ∧
      l⍺pha←2
SYNTAX ERROR
      l ⍺ pha←2
        ∧
```

## ⍵

### Omega

Press `C-w` to generate the symbol.

Used as a predefined variable containing _rval_ to anonymous (lambda) function, or _unnamed dfns_. It is defined only inside the lambda function, between the curly braces `{` and `}`.

The variable is read-only (it cannot be modified in any way).

```
      fn←{100+⍵+10}
      fn 2
112
      ⍵+2
SYNTAX ERROR
      ⍵+2
      ∧
      ⍵
SYNTAX ERROR
      ⍵
      ∧
```

## ¯

### High negative sign

Press `C-2` to enter the symbol

#### Monadic

Used to denote a negative number. Not the same as regular `-` (minus) sign.

```apl
      ¯1 2 3
¯1 2 3
      ¯(1 2 3)
SYNTAX ERROR: Invalid token
      ¯(1 2 3)
      ∧
```

Can be applied only to numeric literals

```apl
      a←2
      ¯2
¯2
      ¯a
SYNTAX ERROR: Invalid token
      ¯ a
      ∧
```

#### Dyadic

No use

```apl
      2¯3
SYNTAX ERROR: Invalid token
      2¯ 3
      ∧
```

## ≠

### Not Equal

Press `C-8` to enter the symbol.

#### Monadic

No use

#### Dyadic

Both arguments can be any array. _Result_ is Boolean.

_Result_ is 0 if _lval_=_rval_. Otherwise, _result_ is 1.

Note: `⎕CT` and `⎕DCT` are implicit arguments of `Not Equal` function.

```apl
      1 ≠ 1.0000000000001
1
      1 ≠ 1.00000000000001
0
```

Note: Function `Not Equal` can be used as `XOR` function for booleans:

```apl
      1 0 1 0 ≠ 1 1 0 0
0 1 1 0
      1 0 1 0 = 1 1 0 0
1 0 0 1
```

## =

### Equality

Regular `=` sign will work, but there is `C-5` also.

#### Monadic

No use

```apl
      =1
SYNTAX ERROR: The function requires a left argument
      =1
      ∧
```

#### Dyadic

Both arguments can be any array. _Result_ is boolean.

`⎕CT` and `⎕DCT` are implicit arguments of _Equal_ function.

If arguments are refs, then _result_ is 1 if they are refs to the same object. If _larg_ is a ref and _rval_ is
not, or vice-versa, then _result_ is 0.

If arguments are character, then _result_ is 1 if they are the same character. If one argument is character and
other is numeric, then _result_ is 0.

```apl
      'a' = 'a'
1
      'asdf' = 'asdf'
1 1 1 1
      'a' = 65
0
      1 = 'a'
0
      '1' = 1
0
```

If arguments are numeric, then _result_ is 1 if _lval_ and _rval_ are within comparison tolerance of each
other.

For real numbers _lval_ and _rval_, _lval_ is considered equal to _rval_ if `(|lval-rval)` is not greater than
`⎕CT×(|lval)⌈|rval`.

```apl
      1= 1
1
      1 = 1.0
1
      1 = 1.0000000000001
0
      1 = 1.00000000000001
1
      1 = 0.99999999999999
1
      1 = 0.9999999999999
0
      ⎕CT
1E¯14
```

For complex numbers _result_ is 1 if the magnitude of _lval_-_rval_ does not exceed `⎕CT` times
the larger of the magnitudes of _lval_ and _rval_; geometrically, _lval_=_rval_ if the number smaller in
magnitude lies on or within a circle centred on the one with larger magnitude, having
radius `⎕CT` times the larger magnitude.

```apl
      a←2+0j1×⎕CT
      a
2J1E¯14
      a=2j.00000000000001 2j.0000000000001
1 0
```

## ≤

### Less than or equal (LTE)

Use `C-4` to generate the symbol.

#### Monadic

No use

```apl
      ≤3
SYNTAX ERROR: The function requires a left argument
      ≤3
      ∧
```

#### Dyadic

Arguments should be numeric arrays. _Result_ is boolean. _Result_ is 1 if _lval_ is lesser than or equal to_rval_. Otherwise _result_ is 0.

```apl
      1 2 3 4 5≤3
1 1 1 0 0
      3≤1 2 3 4 5
0 0 1 1 1
      1 2 3 4 5≤5 4 3 2 1
1 1 1 0 0
```

Note: `⎕CT` and `⎕DCT` are implicit arguments of _LTE_ (≤) function.

```apl
      floats←0.3333333333333 0.33333333333333 0.333333333333333
      floats≤÷3
1 1 1
      1 0.999999999999999 0.9999999999999 ≤ 1
1 1 1
      1 1.000000000000001 1.0000000000001 ≤ 1
1 1 0
      ⎕CT
1E¯14
      ⎕DCT
1E¯28
```

Note: the function _LTE_ is not defined for complex numbers

```apl
      2j3≤3j4
DOMAIN ERROR
      2J3≤3J4
         ∧
```

## <

### Less than (LT)

Usual symbol `S-,` will work, although there is `C-3` also.

#### Monadic

No use

```apl
      <3
SYNTAX ERROR: The function requires a left argument
      <3
      ∧
```

#### Dyadic

Arguments should be numeric arrays. _Result_ is boolean. _Result_ is 1 if _lval_ is lesser than _rval_. Otherwise _result_ is 0.

```apl
      1 2 3 4 5<3
1 1 0 0 0
      3<1 2 3 4 5
0 0 0 1 1
      1 2 3 4 5<5 4 3 2 1
1 1 0 0 0
```

Note: `⎕CT` and `⎕DCT` are implicit arguments of _Less_ _Than_ function.

```apl
      floats←0.3333333333333 0.33333333333333 0.333333333333333
      floats<÷3
1 0 0
      1 0.999999999999999 0.9999999999999 <1
0 0 1
      ⎕CT
1E¯14
      ⎕DCT
1E¯28
```

Note: the function _Less_ _Than_ is not defined for complex numbers

```apl
      2j3<3j4
DOMAIN ERROR
      2J3<3J4
         ∧
```

## >

### Greater than (GT)

Usual symbol `S-.` will work, though there is `C-7` also.

#### Monadic

No use

```apl
       >3
SYNTAX ERROR: The function requires a left argument
      >3
      ∧
```

#### Dyadic

Arguments should be numeric arrays. _Result_ is boolean. _Result_ is 1 if _lval_ is greater than _rval_. Otherwise _result_ is 0.

```apl
      1 2 3 4 5>3
0 0 0 1 1
      3>1 2 3 4 5
1 1 0 0 0
      1 2 3 4 5>5 4 3 2 1
0 0 0 1 1
```

Note: `⎕CT` and `⎕DCT` are implicit arguments of _Greater_ function.

```apl
      floats←0.3333333333333 0.33333333333333 0.333333333333333
      floats>÷3
0 0 0
      1 1.000000000000001 1.0000000000001 > 1
0 0 1
      ⎕CT
1E¯14
      ⎕DCT
1E¯28
```

Note: the function is not defined for complex numbers

```apl
      2j3>3j4
DOMAIN ERROR
      2J3>3J4
         ∧
```

## ≥

### Greater than or equal (GTE)

Press `C-6` to enter the symbol.

#### Monadic

No use

```apl
      ≥3
SYNTAX ERROR: The function requires a left argument
```

#### Dyadic

Arguments should be numeric scalars/arrays. _Result_ is Boolean. _Result_ is 1 if _lval_ is greater than _rval_ or
if _lval_=_rval_. Otherwise _result_ is 0.

```apl
      1 2 3 4 5≥3
0 0 1 1 1
      3≥1 2 3 4 5
1 1 1 0 0
      1 2 3 4 5≥5 4 3 2 1
0 0 1 1 1
```

Note: `⎕CT` and `⎕DCT` are implicit arguments of _Greater_ _Or_ _Equal_ function.

```apl
      floats←0.3333333333333 0.33333333333333 0.333333333333333
      floats≥÷3
0 1 1
      ⎕CT
1E¯14
      ⎕DCT
1E¯28
```

Note: the function is not defined for complex numbers

```apl
      2j3≥3j4
DOMAIN ERROR
      2J3≥3J4
         ∧
```

## ⊆

### Left Shoe Underbar

(Cannot find the way to print this character; I have copied it from here and it works)

#### Monadic

Classic Edition: the symbol ⊆ (Left Shoe Underbar) is not available in Classic
Edition, and Nest is instead represented by ⎕U2286.

#### Dyadic

Classic Edition: the symbol ⊆ (Left Shoe Underbar) is not available in Classic
Edition, and Partition is instead represented by ⎕U2286.

The full usage scheme of the function is _result_ ←  _lval_ ⊆ [_index_] _rval_, where _rval_ is any non-scalar array,
_lval_ is simple scalar or vector of non-negative integers, _index_ is optional along with its square brackets and should be simple integer scalar (or one-element array) representing an axis of _rval_. If _index_ is not specified, the last axis is used by default.

_Result_ is an array of the elements of _rval_ partitioned according to _lval_.


## ∇

### Del (aka Carrot)

Press `C-g` to generate the symbol

## ∆

### Delta

Press `C-h` to generate the symbol.

This symbol can be used in regular variable names along with other alphanumeric symbols,

```apl
      a b←4 5
      ∆←a-b
      ∆
¯1
```
Again, it has no special meaning as a function/operator.

## ∨

### Logical Or

#### Monadic

No use

#### Dyadic

##### If _rval_ and _lval_ are both boolean,

...then _result_ is also boolean, nothing special about logical _or_,

```apl
      0 0 1 1∨0 1 0 1
0 1 1 1
      0∨0 1
0 1
      0 1∨0
0 1
```

##### If one of, or both _lval_ and _rval_ are numeric,

...then _result_ is the Greatest Common Divisor of _lval_ and _rval_.

```apl
      10 11 12 13 14 15 16∨4
2 1 4 1 2 1 4
      10 11 12 13 14 15 16∨8
2 1 4 1 2 1 8
      10 11 12 13 14 15 16∨32
2 1 4 1 2 1 16
      10 11 12 13 14 15 16∨5
5 1 1 1 1 5 1
      10 11 12 13 14 15 16∨7
1 1 1 1 7 1 1
```

**NB:** in this case, `⎕CT` and `⎕DCT` are implicit arguments to a '∨' function.

## ∧

### Logical And

Press `C-0` to generate the symbol. More convenient `S-6` will also work, though.

#### Monadic

No use

#### Dyadic

##### If _rval_ and _lval_ are both boolean,

...then _result_ is also boolean, nothing special about logical and,

```apl
      0 1 0 1 ∧ 1 1 0 0
0 1 0 0
      0 1 0 1 ∧ 1
0 1 0 1
      0 1 0 1 ∧ 0
0 0 0 0
      1 ∧ 1 1 0 0
1 1 0 0
      0 ∧ 1 1 0 0
0 0 0 0
```

##### If one of, or both _lval_ and _rval_ are numeric,

...then _result_ is the Least Common Multiple of _lval_ and _rval_.

```apl
      0 1 2 3 5 15 ∧ 1 2 3 4 5 35
0 2 6 12 5 105
      5 ∧ 1 2 3 4 5 6 7 8 9
5 10 15 20 5 30 35 40 45
```

**NB:** in this case, `⎕CT` and `⎕DCT` are implicit arguments to a '^' function.

## ⍱

### Nor

Press `C-S-9` to generate the symbol.

#### Monadic

No use

```apl
      ⍱78
SYNTAX ERROR: The function requires a left argument
      ⍱78
      ∧
```

#### Dyadic

Logical _Not∘Or_ function. Defined only for boolean scalars/arrays. All the other values will throw DOMAIN ERROR.

```apl
      0 0 1 1⍱0
1 1 0 0
      0⍱0 1 0 1
1 0 1 0
      0 0 1 1⍱0 1 0 1
1 0 0 0
```

## ⍲

### Nand

Press `C-S-0` to generate (FIXME: it doesn't work for me with US keyboard in my Dyalog APL session)

#### Monadic

No use

#### Dyadic

Logical _Not∘And_ function. Defined only for boolean scalars/arrays. All the other values throws DOMAIN ERROR.

```apl
      0 0 1 1⍲0 1 0 1
1 1 1 0
      1⍲0 1 0 1
1 0 1 0
      0 0 1 1⍲1
1 1 0 0
```

## ⍫

TODO: On my keyboard in Dyalog APL session it's `C-S-2`. No mention of the symbol in 'Mastering Dyalog APL', nor in 'Dyalog APL Language Reference guide'. After rendering i see a _del_ symbol with tilda on top of it.

## ⍙

### Delta-underscored or delta-underbar

Press `C-S-;` to enter the symbol. (The 'Mastering Dyalog APL' says it should be `C-.` but it doesn't work for me).  

This symbol can be used in regular variable names along with other alphanumeric symbols,

```apl
      ⍙var←234
      ⍙var
234
      a⍙var←23 34 45
      a⍙var
23 34 45
```

## ß

It is generated when I press `C-.` in my Dyalog APL session.

### it's not Beta, it seems like german double S

Can be used in variable names,

```apl
     scheiße←0 ¯0
     scheiße
0 0
     ßstaring_letter←¯1 0 1
     ßstaring_letter
¯1 0 1
```

## Other, unsorted

Just a placeholder for now.

Maybe will take shortnotes here.

Maybe it's a place to describe operators.

Or trains.

Or Quad-symbols.

But unsorted. For now.
