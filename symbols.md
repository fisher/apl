The charset
===========

 `⍝ ←+-×÷*⍟⌹○!? |⌈⌊⊥⊤⊣⊢ =≠≤<>≥≡≢ ∨∧⍱⍲ ↑↓⊂⊃⌷⍋⍒ ⍳⍷∪∩∊~ /\⌿⍀,⍪⍴⌽⊖⍉ ¨⍨⍣.∘⍤ ⍞⎕⍠⌸⍎⍕ ⋄→⍵⍺∇& ⍙∆ß¢⍫⌶ ¯⍬`
 
TOC-like table
==============

|          |          |          |          |          |          |          |          |
|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|
| [⍝](#) | [←](#-1) | [+](#-2)  | [-](#-) | [×](#-3)  | [÷](#-4) | [*](#-5) | [⍟](#-6) |
| [⌹](#-7)|[⌷](#-8) | [⍞](#-9)| [⎕](#-10)|[⍠](#-11)|[⌸](#-12)| [!](#-13)| [?](#-14) |
| [○](#-15)| [\|](#-16)| [⌈](#-17)| [⌊](#-18) |[⊥](#-19) |[⊤](#-20)| [⊣](#-21)| [⊢](#-22) |
| [≡](#-23) |[≢](#-24) |[↑](#-25) |[↓](#-26) |[⊂](#-27) |[⊃](#-28) |[⍋](#-29) |[⍒](#-30) |
| [&](#-31) | [⌶](#-32) | [⍳](#-33) | [⍷](#-34) | [∊](#-35) | [∪](#-36) | [∩](#-37) | [⍴](#-38) |
| [⋄](#-39) | [→](#-40) | [,](#-41) | [⍪](#-42) | [¨](#-43) | [⍨](#-44) | [⍣](#-45) | [⍤](#-46) |
| [~](#-47) | [/](#-48) | [\\](#-49) | [⌿](#-50) | [⍀](#-51) | [⌽](#-52) | [⊖](#-53) | [⍉](#-54) |
| [∘](#-55) | [⍬](#-56) | [.](#-57) | [¢](#-58) | [⍎](#-59) | [⍕](#-60) | [⍺](#-61) | [⍵](#-62) |
| [¯](#-63) | [≠](#-64) | [=](#-65) | [≤](#-66) | [<](#-67) | [>](#-68) | [≥](#-69) | [⊆](#-70) |
| [∇](#-71) | [∆](#-72) | [∨](#-73) | [∧](#-74) | [⍱](#-75) | [⍲](#-76) | [⍫](#-77) | [⍙](#-78) |

[ß](#ß)

Placeholder for [Other, unsorted](#other-unsorted) symbols and notes

One rune per day challenge
==========================

I decided to spend a small fraction of my time each day for just one symbol from the language. The trick is in this `each day` part. First day will be an exception, because it's nothing special about comments, assignments and arythmetics.

## ⍝

### A comment

Nothing special about it, comment out from the symbol till the end of a line.

Press `C-M-,` to comment out the current line, `C-M-.` removes comment mark from the line.
The symbol itself can be generated by `C-S-,`

```apl
⍝___________________
⍝ ... Gibberish mojo
⍝¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

foo/bar ⍝ ... blablabla
```

## ←

### Assingment

#### Monadic

_No use_

#### Dyadic

Assigns _rval_ to the _lval_. Just press `C-]` to generate the symbol.

```apl
a←10
another_variable ← 200 + a
(yet_another1 yet_another2) ← 100   ⍝ ... yet_another1 = 100, yet_another2 = 100
(yet_another1 yet_another2) ← 10 20  ⍝ ... yet_another1 = 10, yet_another2 = 20
var1 ← var2 ← var3 ← 0  ⍝ ... all three vars are 0 now
```

#### Assignment with index

Reading right to left, `Variable[index_vector] ← values_vector` means assignment of _values_vector_ to (vector) _Variable_ addressed by _index_vector_.

```apl
var ← ⍳5           ⍝ ... var is 1 2 3 4 5
var[2 3] ← 111     ⍝ ... var is 1 111 111 4 5
var[2 3] ← 222 333 ⍝ ... var is 1 222 333 4 5
var[4 4] ← 444 555 ⍝ ... var is 1 222 333 555 5
```

Shape should agree:

```apl
      var ← 2 3⍴ ⍳6 ⋄var
1 2 3
4 5 6
      var[1 2;2 3]←2 2⍴44 55 ⋄var
1 44 55
4 44 55
      var[1 2;2]←2 1⍴66 77 ⋄ var
1 66 55
4 77 55
```

## +

### Plus

Just a regular plus sign.

#### Monadic

Identity. Returns _rval_ as is.

```apl
var ← +¯10 20 ⍝ ... var is now ¯10 20
```
#### Dyadic

Addition. Sums _lval_ and _rval_. Both can be scalars or vectors. Both should be numeric.

```apl
res ← 1 2 3 + 4 5 6 ⍝ ... res is 5 7 9
res ← 1 2 3 + 4     ⍝ ... res is 5 6 7, rval expands to the length of lval (4 4 4)
res ← 1 + 2 3 4     ⍝ ... res is 3 4 5, lval expands to the length of rval (1 1 1)
res ← 2 3 4 + 10 20 ⍝ ... throws LENGTH ERROR: Mismatched left and right argument shapes
```

## -

### Minus

Regular minus sign.

#### Monadic

Negates the number.

```apl
var ← -10    ⍝ ... var is now ¯10
var ← - 4j7  ⍝ ... var is ¯4j¯7
```
#### Dyadic

Substraction.

Both _rval_ and _lval_ can be scalar or array, both should be numeric. Result is numeric.

```apl
var ← 5 - 2 3 4  ⍝ ... var is 3 2 1 (lval extends to the length of the rval, (5 5 5))
var ← 5 4 3 - 2  ⍝ ... var is 3 2 1 (rval expands to the length of the lval, (2 2 2))
var ← 2j3 - .3j5 ⍝ ... var is 1.7J¯2; (a+bi)-(c+di) = (a-c)+(b-d)i
```

## ×

### Multiplication

Press `C-=` to generate the symbol.

#### Monadic

Sign of. (AKA _signum_, AKA _direction_).

For integers and floats, the function returns ¯1, 0, or 1 for negative, zero or positive argument, respectively.

```apl
var ← × 12 0 ¯12 ⍝ ... var now contains vector 1 0 ¯1
```

For complex numbers, monadic _signum_ is equivalent to _rval_ ÷| _rval_.

```apl
var ← × 3j4 4j5       ⍝ ... var is 0.6J0.8 0.6246950476J0.7808688094
res ← {⍵÷|⍵} 3j4 4j5 ⍝ ... res is 0.6J0.8 0.6246950476J0.7808688094
res ← | ×3j4 4j5      ⍝ ... res is 1 1
```

#### Dyadic

Multiplication. Surprise-surprise

```apl
res ← 1 2 3 × 4 5 6 ⍝ ... res is 4 10 18, a b c × x y z = a×x b×y c×z
res ← 1 2 3 × 4     ⍝ ... res is 4 8 12, rval expands to the length of lval (4 4 4)
res ← 1 × 2 3 4     ⍝ ... res is 2 3 4,  lval expands to the length of rval (1 1 1)
res ← 2j3 × 1 4 5j6 ⍝ ... res is 2j3 8j12 ¯8j27
res ← 2 3 4 × 10 20 ⍝ ... throws LENGTH ERROR: Mismatched left and right argument shapes
```

## ÷

### Division

Press `C-[` to generate the symbol.

#### Monadic

Reciprocal. Returns 1/_rval_ relation.

```apl
var ← ÷ 1 2 3 4 5  ¯4 ¯5 ⍝ ... var now 1 0.5 0.33333333333333 0.25 0.2 ¯0.25 ¯0.2
```

Internal representation seems not to be simple IEEE 754, at least it successfully passes the well-known pitfall with floating point division:

```apl
var ← ÷ 3    ⍝ ... var now 0.33333333333333
var ← var ×3 ⍝ ... var is 1 again
```

...but looks like a workaround for boundary case. In example below, first multiplication is using 14 digits after the dot, while the second is using 15 digits precision.

```apl
      0.33333333333333×3
0.99999999999999
      0.333333333333333×3
1
```

**NB:** `÷0` throws `DOMAIN ERROR: Divide by zero` if `⎕DIV` equals to 0; if `⎕DIV` = 1, `÷0` returns 0.

By default, `⎕DIV` equals to 0.

#### Dyadic

Division.

```apl
var ← 6 ÷ 3 ⍝ ... var = 2
```

**NB:** System variable `⎕DIV` is an implicit argument of division function. In pseudocode:

If (_rval_ == 0)
  - If (_⎕DIV_ == 0)
    + If (_lval_ == 0)
      * return 1;
    + Else
      * throw 'DOMAIN ERROR';
  - Else
    + return 0;

```apl
⎕DIV ← 1
var ← ¯1 0 1 ÷ 1 1 1  ⍝ ... var = ¯1 0 1
var ← ¯1 0 1 ÷ 0 0 0  ⍝ ... var =  0 0 0
⎕DIV ← 0
var ← ¯1 0 1 ÷ 1 1 1  ⍝ ... var = ¯1 0 1
var ← ¯1 0 1 ÷ 0 0 0  ⍝ ... throws DOMAIN ERROR because of first and last cases, ¯1÷0 and 1÷0
var ← 0 0 0 ÷ ¯1 0 1  ⍝ ... var =  0 1 0
```

By default, `⎕DIV` equals to 0.

## *

### Exponentiation

Regular asterisk sign.

#### Monadic

Exponential (reverse of natural logarithm)

_rval_ should be numeric. Result is numeric and equals to the _rval_'s power of _e_, i.e. _e_<sup>rval</sup>

```apl
var ← * 1 0 ⍝ ... var equals to 2.718281828 1
```

#### Dyadic

Power

```apl
var ← 10 * 3 ⍝ ... var equals to 1000
```

Common idiom is to find a square root by powering to 1/2,

```apl
var ← 16 * ÷2 ⍝ ... this gives us the square root of 16, 4
var ← 27 * ÷3 ⍝ ... this gives us the cubic root of 27, it's 3
var ← 16 * ÷4 ⍝ ... equals to 2
```

## ⍟

### Logarithm

Press `C-S-8` to generate the symbol.

#### Monadic

Natural logarithm

```apl
      ⍟10 100 1000 10000
2.302585092994 4.6051701859881 6.9077552789821 9.2103403719762
      ⍟2 4 8 16 32
0.69314718055995 1.3862943611199 2.0794415416798 2.7725887222398 3.4657359027997
      ⍟1
0
      *1
2.718281828459
      ⍟*1
1
      {⍵:⎕←'yep'⋄⎕←'nope'}1=⍟*1
yep
```

#### Dyadic

Logarithm of a given _lval_ base

Defined in terms of monadic (natural) logarithm: `lval ⍟ rval == (⍟rval) ÷ ⍟lval`

```apl
var ← (10⍟100)                 ⍝ ... var equals to 2
bool← (10⍟100) = (⍟100)÷⍟10   ⍝ ... bool is 1
base← 16⍟256 512 1024 2048 4096 ⍝ ... base is vector 2 2.25 2.5 2.75 3
```

## ⌹

### Matrix divide (aka domino)

Press `C-S-[` to generate the symbol. Associate with regular division, which is `C-[`.

There are some similarities between this sign (⌹) and division sign ([÷](#-4)) - Matrix division looks the same, but in frame.

#### Monadic

'Matrix inverse of'.

#### Dyadic

'Matrix division by'.

Both _rval_ and _lval_ must be a simple numeric array of rank 2 or less, and _rval_ must be non-singular.
A scalar argument is treated as a matrix with one-element. If argument is a vector, it is treated as a single column matrix.
The number of rows in both arguments must be the same, and _rval_ must have at least the same number of rows as columns.

The _result_ is the matrix division of _lval_ by _rval_. That is, the matrix product `rval +.× result = lval`.

_result_ is determined such that `(lval - rval +.× result) * 2` is minimised.

The shape of _result_ is `(1↓⍴ rval), 1↓⍴ lval`.

```apl
    (1 4⍴1 2 3 4) ⌹ 2
0.5 1 1.5 2
    (2 4⍴1 2 3 4 5 6 7 8) ⌹ 1 2
2.2 2.8 3.4 4
    (2 4⍴1 2 3 4 5 6 7 8) ⌹ 2
LENGTH ERROR
    (2 4⍴1 2 3 4 5 6 7 8)⌹2
                           ∧
    (2 4⍴1 2 3 4 5 6 7 8) ⌹ (2 2⍴1 2 3 4)
 3 2 1 0
¯1 0 1 2
```

For least square method and linear regression examples please see Language Reference Guide from Dyalog.

## ⌷

### Index (axis)

Press `C-S-L` to generate the symbol. Sometimes called _squad index_ or _squad indexing_. Don't confuse it with quad symbol (which is slightly wider, `⎕`) and with two square brackets ([]).

#### Monadic

_No info_

#### Dyadic

#### Special case, as operator together with square brackets

So called _index with axis_, in the form _lval_ ⌷[_index_] _rval_

## ⍞

### Quoted quad

#### Monadic

#### Dyadic

## ⎕

### Quad

#### Monadic

#### Dyadic

## ⍠

### Variant

#### Monadic

#### Dyadic

## ⌸

### Key

#### Monadic

#### Dyadic

## !

### Exlamation mark (factorial, binomial)

#### Monadic

Factorial.

```apl
      !1 2 3 4 5
1 2 6 24 120
```

#### Dyadic

Binomial coefficient. Number of combinations of _rval_ items taken _lval_ at a time

```apl
      1 2 3 4 5 6!6
6 15 20 15 6 1
      2!4 5 6 7 8
6 10 15 21 28
      3!4 5 6 7 8
4 10 20 35 56
      4!4 5 6 7 8
1 5 15 35 70
      5!4 5 6 7 8
0 1 6 21 56
      6!4 5 6 7 8
0 0 1 7 28
```

## ?

### Question mark (Roll, Deal)

#### Monadic

Roll.

#### Dyadic

Deal. Takes sample of lenght _lval_ out of set of integers created by ⍳_rval_, i.e. first _rval_ integers, starting from ⎕IO.

Both arguments should be scalar, both positive integers, _rval_ should be greater than or equal to _lval_.

Again, it doesn't work with vectors.

```apl
      2?8
3 6
      8?8
7 2 4 3 1 5 6 8
```

⎕IO and ⎕RL are implicit arguments of Deal. A side effect of Deal is to change the value of ⎕RL.

## ○

### Circular (π-times)

Press 'C-o' to enter the symbol.

#### Monadic

So called π× or pi-times.

Multiplication by the value of π constant, so _rval_ should be numeric, and _result_ will be numeric.

```apl
    ○0 1 2
0 3.1415926535898 6.2831853071796
    ○1j2 2j1 1j1
3.1415926535898J6.2831853071796 6.2831853071796J3.1415926535898 3.1415926535898J3.1415926535898
```

Non-numeric _rval_ produces DOMAIN ERROR.

#### Dyadic

So called 'circular'. Key combo is, again, 'C-o'.

_Result_ depends on the _lval_ value, which can be an integer in the range `¯12 ... 12`. The _rval_ should be numeric in any case. _Result_ is always numeric.

## \|

### Pipe symbol (residue, magnitude)

Usual pipe symbol, press `S-\\` to enter it.

#### Monadic

Magnitude, AKA absolute value. For any numberic _rval_ returns its absolute value. Can operate on arrays.

```apl
      |¯2 ¯1 0 1 2
2 1 0 1 2
      |¯1.5 ¯0.5 0 0.5 1.5
1.5 0.5 0 0.5 1.5
```

Note that the magnitude for a complex number (`a`+i`b`) is defined to be the square root of the sum of `a` squared and `b` squared, i.e. sqrt(a<sup>2</sup>+b<sup>2</sup>).

```apl
      |3j4 5j12
5 13
      |3j12 3j13
12.369316876853 13.341664064126
```

#### Dyadic

Residue.

Arguments are numeric scalars/arrays.

For positive arguments, _result_ is the remainder when _rval_ is divided by _lval_. If _lval_=0, _result_ equals to _rval_.

For other argument values, _result_ is defined as `rval - lval × ⌊ rval ÷ lval + 0 = lval`.
This expression also applies when _lval_ and/or _rval_ are complex but the simple `⌊` is replaced by
the `CpxFloor` function. See [Complex Floor](#-18) function.

```apl
      1 2 3 4 5 6|6
0 0 0 2 1 0
      3|3 4 5 6
0 1 2 0
      4|4 5 6 7 8 9 10 11 12
0 1 2 3 0 1 2 3 0
      3 3 ¯3 ¯3|5 ¯5 4 ¯4
2 1 ¯2 ¯1
      0.5|3.1415 ¯1 ¯0.7
0.1415 0 0.3
      1j2|2j3 3j4 5j6
1J1 ¯1J1 0J1
```
Since this operation involves division, ⎕CT and ⎕DCT are implicit arguments of _Residue_.

## ⌈

### Upstile (maximum, ceiling)

Press `C-s` to generate the symbol.

#### Monadic

Ceiling.

The argument should be a numeric array.

The _ceiling_ function is defined in terms of [floor](#-18) as `⌈ rval ←→ - ⌊ -rval`.

If an element of _rval_ is real, the corresponding element of _result_ is the least integer greater
than or equal to the value of _rval_.

If an element of _rval_ is complex, the corresponding element of _result_ depends on the
relationship between the real and imaginary parts of the numbers in _rval_.

`⎕CT` is an implicit argument of the _ceiling_ function.

#### Dyadic

Maximum.

Both arguments should be numeric scalars/arrays. If both argumets are arrays, the length/rank should be the same. _Result_ is the maximum of the two sets of _lval_ and _rval_.

```apl
      3⌈1 2 3 4
3 3 3 4
      1 2 3 4⌈3
3 3 3 4
      1 2 3 4⌈4 3 2 1
4 3 3 4
      (2 3⍴(1 2 3 4 5 6))⌈2 3⍴3
3 3 3
4 5 6
      0.2 0.3 0.4 0.5⌈0.3
0.3 0.3 0.4 0.5
```

This function is undefined for complex numbers.

## ⌊

### Downstile (minimum, floor)

Press `C-d` to generate the symbol.

#### Monadic

Floor.

The argument is a numeric array.

##### Real numbers

For real numbers, _result_ is the largest integer value less than or equal to _rval_ within the
comparison tolerance `⎕CT`.

```apl
      ⌊¯1.3 ¯0.7 ¯0 0 0.3 0.7 3.9999999999999
¯2 ¯1 0 0 0 0 3
      ⌊¯1.3 ¯0.7 ¯0 0 0.3 0.7 3.99999999999999
¯2 ¯1 0 0 0 0 4
      ⎕CT
1E¯14
```

##### Complex numbers

The following (deliberately) simple function illustrates one way to express the rules
for evaluating complex _Floor_.

```apl
     ∇ fl←CpxFloor cpxs;a;b
[1]   ⍝ Complex floor of scalar complex number (a+ib)
[2]   a b←9 11○cpxs
[3]   :If 1>(a-⌊a)+b-⌊b
[4]      fl←(⌊a)+0J1×⌊b
[5]   :Else
[6]      :If (a-⌊a)<b-⌊b
[7]         fl←(⌊a)+0J1×1+⌊b
[8]      :Else
[9]         fl←(1+⌊a)+0J1×⌊b
[10]     :EndIf
[11]  :EndIf
     ∇

     CpxFloor¨1j3.2 3.3j2.5 ¯3.3j¯2.5
1J3 3J2 ¯3J¯3
```

`⎕CT` and `⎕DCT` are implicit arguments of the _Floor_ function.

#### Dyadic

Minimum.

Both arguments should be numeric arrays, floats or integers (no comples numbers!). If both arguments are arrays, the length should
be the same. The _result_ is the array of minimum elements from two sets of arguments.

```apl
      3⌊1 2 3 4 5
1 2 3 3 3
      1 2 3 4 5⌊3
1 2 3 3 3
      1 2 3 4 5⌊5 4 3 2 1
1 2 3 2 1
      (2 3⍴(1 2 3 4 5 6))⌊2 3⍴3
1 2 3
3 3 3
      0.2 0.3 0.4 0.5 0.6⌊0.3
0.2 0.3 0.3 0.3 0.3
      2j3⌊3j4
DOMAIN ERROR
      2J3⌊3J4
         ∧
```

## ⊥

### Decode

#### Monadic

#### Dyadic

## ⊤

### Encode

#### Monadic

#### Dyadic

## ⊣

### Same, left

#### Monadic

#### Dyadic

## ⊢

### Same, right

#### Monadic

#### Dyadic

## ≡

### Depth, match

#### Monadic

#### Dyadic

## ≢

Note: depending on the font used, this symbol can be seen as `depth` symbol with slash attached to its left; the proper look should be `depth` symbol that is crossed out by a slash, from top right to bottom left, in one placeholder.

### Not match, tally

#### Monadic

#### Dyadic

## ↑
### Disclose, mix, take
## ↓
### Drop, split
## ⊂
### Left shoe
## ⊃
### Right shoe
## ⍋
## ⍒
## &
## ⌶
## ⍳
## ⍷
## ∊
## ∪
## ∩
## ⍴
## ⋄
## →

### Abort, Branch

#### Nilladic

Abort. This is a special case of the Branch function used in the niladic sense. If it occurs in a
statement it must be the only symbol in an expression or the only symbol forming an
expression in a text string to be executed by ⍎. It clears the most recently suspended
statement and all of its pendent statements from the state indicator.
The Abort function has no explicit result. The function is not in the function domain
of operators.

```apl
   ∇ F
[1] 'F[1]'
[2] G
[3] 'F[3]'
   ∇
   ∇ G
[1] 'G[1]'
[2] →
[3] 'G[3]'
   ∇
   F
F[1]
G[1]
```

#### Monadic

Branch. _Rval_ may be a scalar or vector which, if not empty, has a simple numeric scalar as its first
element. The function has no explicit result. It is used to modify the normal
sequence of execution of expressions or to resume execution after a statement has
been interrupted. Branch is not in the function domain of operators.

**TODO**

#### Dyadic

_No use_

## ,
## ⍪
## ¨
## ⍨
## ⍣
## ⍤
## ~
## /
## \\
## ⌿
## ⍀
## ⌽
## ⊖
## ⍉
## ∘
## ⍬
## .
## ¢
## ⍎
## ⍕
## ⍺
## ⍵
## ¯
## ≠
## =
## ≤
## <
## >

### Greater than (GT)

## ≥

### Greater than or equal (GTE)

## ⊆
### Left Shoe Underbar

#### Monadic

Classic Edition: the symbol ⊆ (Left Shoe Underbar) is not available in Classic
Edition, and Nest is instead represented by ⎕U2286.

#### Dyadic

Classic Edition: the symbol ⊆ (Left Shoe Underbar) is not available in Classic
Edition, and Partition is instead represented by ⎕U2286.

## ∇

### Del (aka Carrot)

Press `C-g` to generate the symbol

## ∆

### Delta

Press `C-h` to generate the symbol.

This symbol can be used in regular variable names along with other alphanumeric symbols,

```apl
      a b←4 5
      ∆←a-b
      ∆
¯1
```
Again, it has no special meaning as a function/operator.

## ∨

### Logical Or

#### Monadic

No use

#### Dyadic

##### If _rval_ and _lval_ are both boolean,

...then _result_ is also boolean, nothing special about logical _or_,

```apl
      0 0 1 1∨0 1 0 1
0 1 1 1
      0∨0 1
0 1
      0 1∨0
0 1
```

##### If one of, or both _lval_ and _rval_ are numeric,

...then _result_ is the Greatest Common Divisor of _lval_ and _rval_.

```apl
      10 11 12 13 14 15 16∨4
2 1 4 1 2 1 4
      10 11 12 13 14 15 16∨8
2 1 4 1 2 1 8
      10 11 12 13 14 15 16∨32
2 1 4 1 2 1 16
      10 11 12 13 14 15 16∨5
5 1 1 1 1 5 1
      10 11 12 13 14 15 16∨7
1 1 1 1 7 1 1
```

**NB:** in this case, `⎕CT` and `⎕DCT` are implicit arguments to a '∨' function.

## ∧

### Logical And

Press `C-0` to generate the symbol. More convenient `S-6` will also work, though.

#### Monadic

No use

#### Dyadic

##### If _rval_ and _lval_ are both boolean,

...then _result_ is also boolean, nothing special about logical and,

```apl
      0 1 0 1 ∧ 1 1 0 0
0 1 0 0
      0 1 0 1 ∧ 1
0 1 0 1
      0 1 0 1 ∧ 0
0 0 0 0
      1 ∧ 1 1 0 0
1 1 0 0
      0 ∧ 1 1 0 0
0 0 0 0
```

##### If one of, or both _lval_ and _rval_ are numeric,

...then _result_ is the Least Common Multiple of _lval_ and _rval_.

```apl
      0 1 2 3 5 15 ∧ 1 2 3 4 5 35
0 2 6 12 5 105
      5 ∧ 1 2 3 4 5 6 7 8 9
5 10 15 20 5 30 35 40 45
```

**NB:** in this case, `⎕CT` and `⎕DCT` are implicit arguments to a '^' function.

## ⍱

### Nor

Press `C-S-9` to generate the symbol.

#### Monadic

No use

#### Dyadic

Logical _Not∘Or_ function. Defined only for boolean scalars/arrays. All the other values will throw DOMAIN ERROR.

```apl
      0 0 1 1⍱0
1 1 0 0
      0⍱0 1 0 1
1 0 1 0
      0 0 1 1⍱0 1 0 1
1 0 0 0
```

## ⍲

### Nand

Press `C-S-0` to generate (FIXME: it doesn't work for me with US keyboard in my Dyalog APL session)

#### Monadic

No use

#### Dyadic

Logical _Not∘And_ function. Defined only for boolean scalars/arrays. All the other values throws DOMAIN ERROR.

```apl
      0 0 1 1⍲0 1 0 1
1 1 1 0
      1⍲0 1 0 1
1 0 1 0
      0 0 1 1⍲1
1 1 0 0
```

## ⍫

TODO: On my keyboard in Dyalog APL session it's `C-S-2`. No mention of the symbol in 'Mastering Dyalog APL', nor in 'Dyalog APL Language Reference guide'. After rendering i see a _del_ symbol with tilda on top of it.

## ⍙

### Delta-underscored or delta-underbar

Press `C-S-;` to enter the symbol. (The 'Mastering Dyalog APL' says it should be `C-.` but it doesn't work for me).  

This symbol can be used in regular variable names along with other alphanumeric symbols,

```apl
      ⍙var←234 
      ⍙var
234
      a⍙var←23 34 45
      a⍙var
23 34 45
```

## ß

It is generated when I press `C-.` in my Dyalog APL session.

### it's not Beta, it seems like german double S

Can be used in variable names,

```apl
     scheiße←0 ¯0
     scheiße
0 0
     ßstaring_letter←¯1 0 1
     ßstaring_letter
¯1 0 1
```

## Other, unsorted

Just a placeholder for now.

Maybe will take shortnotes here.

Maybe it's a place to describe operators.

Or trains.

Or Quad-symbols.

But unsorted. For now.
